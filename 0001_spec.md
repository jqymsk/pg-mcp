# PRD-0001: pg-mcp 功能补全与缺陷修复

| 字段 | 值 |
|------|-----|
| 状态 | Draft |
| 作者 | — |
| 日期 | 2026-02-19 |
| 优先级 | P0 |

---

## 1. 背景

pg-mcp 当前已实现核心查询链路（自然语言 → SQL 生成 → 验证 → 执行 → 结果校验），但在以下三个维度存在设计承诺与实际实现之间的差距：

1. **多数据库与安全控制**：配置层支持多数据库和表/列级访问限制，但 server 启动时仅创建单一数据库连接池和单一 SQLExecutor，Orchestrator 始终使用同一个 executor，无法按请求路由到正确的数据库，也无法对不同数据库实施差异化的表/列访问策略。EXPLAIN 策略虽有 `allow_explain` 参数但在 server.py 中硬编码为 `False`，无法通过配置控制。

2. **弹性与可观测性**：`MetricsCollector`、`MultiRateLimiter`、`CircuitBreaker` 均已实现，但未接入请求处理主链路——Orchestrator 不调用 rate limiter，不记录 metrics，tracing 模块未被任何业务代码引用。

3. **响应模型缺陷与测试覆盖**：`QueryResponse` 存在两个 `to_dict` 方法（第二个覆盖第一个，行为不一致）；`SecurityConfig` 中 `readonly_role`、`safe_search_path` 等字段虽被 executor 使用但缺乏配置文档和测试覆盖；安全测试（SQL 注入、blocked tables/columns）缺少专项测试文件。

---

## 2. 目标

- 使 pg-mcp 能够在单实例中服务多个 PostgreSQL 数据库，并对每个数据库独立实施表/列级访问控制和 EXPLAIN 策略。
- 将已实现的弹性组件（rate limiter、circuit breaker）和可观测性组件（metrics、tracing）接入请求主链路。
- 修复响应模型中的重复方法和不一致行为，补齐安全相关测试覆盖。

---

## 3. 非目标

- 不引入新的 LLM provider 或更换 Gemini SDK。
- 不重构 MCP 协议层或 FastMCP 集成方式。
- 不实现用户认证/授权体系（MCP 协议层面的身份管理）。
- 不实现查询结果缓存。

---

## 4. 功能规格

### 4.1 多数据库支持

#### 4.1.1 配置层扩展

在 `Settings` 中新增 `databases: list[DatabaseConfig]` 字段，支持通过环境变量或 `.env` 配置多个数据库。保留现有 `database: DatabaseConfig` 作为单库快捷配置的向后兼容。

```python
class Settings(BaseSettings):
    database: DatabaseConfig = Field(default_factory=DatabaseConfig)       # 向后兼容
    databases: list[DatabaseConfig] = Field(default_factory=list)          # 多库配置

    def get_all_databases(self) -> list[DatabaseConfig]:
        """合并 database 和 databases，去重后返回。"""
        ...
```

#### 4.1.2 Server 启动时创建多连接池

修改 `server.py` 的 `lifespan` 函数：
- 遍历 `settings.get_all_databases()` 为每个数据库创建独立连接池。
- 为每个数据库创建独立的 `SQLExecutor` 实例。
- 将 `sql_executors: dict[str, SQLExecutor]` 传入 Orchestrator。

#### 4.1.3 Orchestrator 按请求路由 Executor

修改 `QueryOrchestrator`：
- 构造函数接收 `sql_executors: dict[str, SQLExecutor]`（替代单一 `sql_executor`）。
- `execute_query` 中根据 `_resolve_database()` 的结果选择对应的 executor。

```python
class QueryOrchestrator:
    def __init__(self, ..., sql_executors: dict[str, SQLExecutor], ...):
        self.sql_executors = sql_executors

    async def execute_query(self, request):
        database_name = self._resolve_database(request.database)
        executor = self.sql_executors[database_name]
        ...
```

### 4.2 Per-Database 安全控制

#### 4.2.1 Per-Database 安全配置

新增 `DatabaseSecurityConfig` 模型，支持为每个数据库独立配置：

```python
class DatabaseSecurityConfig(BaseModel):
    blocked_tables: list[str] = Field(default_factory=list)
    blocked_columns: list[str] = Field(default_factory=list)
    allow_explain: bool = Field(default=False)
```

在 `DatabaseConfig` 中嵌入：

```python
class DatabaseConfig(BaseSettings):
    ...
    security: DatabaseSecurityConfig = Field(default_factory=DatabaseSecurityConfig)
```

#### 4.2.2 Per-Database SQLValidator

修改 server.py，为每个数据库创建独立的 `SQLValidator` 实例，使用该数据库的 `DatabaseSecurityConfig`：

```python
sql_validators: dict[str, SQLValidator] = {}
for db_config in settings.get_all_databases():
    sql_validators[db_config.name] = SQLValidator(
        config=settings.security,
        blocked_tables=db_config.security.blocked_tables,
        blocked_columns=db_config.security.blocked_columns,
        allow_explain=db_config.security.allow_explain,
    )
```

Orchestrator 同样接收 `sql_validators: dict[str, SQLValidator]`，按数据库名选择对应 validator。

#### 4.2.3 EXPLAIN 策略可配置化

移除 server.py 中 `allow_explain=False` 的硬编码，改为从 `DatabaseSecurityConfig.allow_explain` 读取。

### 4.3 弹性组件接入主链路

#### 4.3.1 Rate Limiter 接入

在 `QueryOrchestrator.execute_query` 入口处使用 `MultiRateLimiter`：

```python
async def execute_query(self, request):
    async with self.rate_limiter.for_queries(timeout=30.0):
        ...
        # 在 LLM 调用处
        async with self.rate_limiter.for_llm(timeout=60.0):
            generated_sql = await self._generate_sql_with_retry(...)
```

Orchestrator 构造函数新增 `rate_limiter: MultiRateLimiter` 参数。

#### 4.3.2 Rate Limiter 配置化

在 `ResilienceConfig` 中新增：

```python
class ResilienceConfig(BaseSettings):
    ...
    max_concurrent_queries: int = Field(default=10, ge=1, le=100)
    max_concurrent_llm_calls: int = Field(default=5, ge=1, le=50)
```

server.py 中使用配置值初始化 `MultiRateLimiter`（替代当前硬编码的 `10` 和 `5`）。

#### 4.3.3 Retry 退避机制

当前 `_generate_sql_with_retry` 在重试时无延迟。增加指数退避：

```python
if attempt < max_retries:
    delay = self.resilience_config.retry_delay * (
        self.resilience_config.backoff_factor ** attempt
    )
    await asyncio.sleep(delay)
```

### 4.4 可观测性接入主链路

#### 4.4.1 Metrics 接入

在 Orchestrator 中注入 `MetricsCollector`，在关键节点记录指标：

| 指标 | 记录位置 |
|------|---------|
| `query_requests` | `execute_query` 完成时，按 status + database 标记 |
| `query_duration` | `execute_query` 整体耗时 |
| `llm_calls` | `_generate_sql_with_retry` 每次 LLM 调用 |
| `llm_latency` | 每次 LLM 调用耗时 |
| `sql_rejected` | SQL 验证失败时 |
| `db_query_duration` | SQL 执行耗时 |

#### 4.4.2 Tracing 接入

在 `execute_query` 入口使用 `request_context` 上下文管理器，确保 request_id 通过 contextvars 传播到所有子调用：

```python
async def execute_query(self, request):
    async with request_context(request_id) as req_id:
        ...
```

将 Orchestrator 中的 `logging.getLogger` 替换为 `get_tracing_logger`。

### 4.5 响应模型修复

#### 4.5.1 修复 QueryResponse 重复 to_dict

`QueryResponse` 类中存在两个 `to_dict` 方法（行 160 和行 214），第二个覆盖第一个。

- 删除第二个 `to_dict`（行 214-220），保留第一个（行 160-173），因为第一个确保 `tokens_used` 始终存在，行为更完整。

#### 4.5.2 移除 QueryResult.to_dict

`QueryResult.to_dict`（行 130-136）仅调用 `model_dump()`，属于冗余方法。Pydantic BaseModel 已提供 `model_dump()`，无需额外包装。删除该方法。

### 4.6 测试补全

#### 4.6.1 安全专项测试

新增 `tests/security/` 目录，包含：

- `test_sql_injection.py`：覆盖常见 SQL 注入变体（UNION 注入、注释截断、多语句、嵌套子查询注入）。
- `test_blocked_access.py`：覆盖 blocked_tables、blocked_columns 的拦截行为，包括大小写变体和 schema 限定名。
- `test_explain_policy.py`：覆盖 EXPLAIN 允许/禁止两种策略。

#### 4.6.2 多数据库集成测试

新增 `tests/integration/test_multi_database.py`：
- 测试多数据库路由正确性。
- 测试 per-database 安全策略隔离。
- 测试数据库不存在时的错误响应。

#### 4.6.3 弹性组件集成测试

新增 `tests/integration/test_resilience_integration.py`：
- 测试 rate limiter 在高并发下的限流行为。
- 测试 circuit breaker 在 LLM 连续失败后的熔断和恢复。
- 测试 retry 退避延迟是否符合配置。

#### 4.6.4 Metrics 集成测试

新增 `tests/unit/test_metrics_integration.py`：
- 测试 Orchestrator 执行查询后 metrics counter 是否正确递增。
- 测试 LLM 调用后 latency histogram 是否记录。

---

## 5. 变更文件清单

| 文件 | 变更类型 | 说明 |
|------|---------|------|
| `src/pg_mcp/config/settings.py` | 修改 | 新增 `DatabaseSecurityConfig`、`databases` 字段、`get_all_databases()`、rate limiter 配置字段 |
| `src/pg_mcp/server.py` | 修改 | 多库连接池创建、per-database validator/executor、注入 rate limiter 和 metrics |
| `src/pg_mcp/services/orchestrator.py` | 修改 | 接收多 executor/validator、接入 rate limiter/metrics/tracing、增加 retry 退避 |
| `src/pg_mcp/models/query.py` | 修改 | 删除重复 `to_dict`、删除冗余 `QueryResult.to_dict` |
| `tests/security/test_sql_injection.py` | 新增 | SQL 注入专项测试 |
| `tests/security/test_blocked_access.py` | 新增 | 表/列访问控制测试 |
| `tests/security/test_explain_policy.py` | 新增 | EXPLAIN 策略测试 |
| `tests/integration/test_multi_database.py` | 新增 | 多数据库路由与隔离测试 |
| `tests/integration/test_resilience_integration.py` | 新增 | 弹性组件集成测试 |
| `tests/unit/test_metrics_integration.py` | 新增 | Metrics 记录正确性测试 |

---

## 6. 实施顺序

1. **Phase 1 — 模型修复**：修复 `QueryResponse` 重复 `to_dict`，移除 `QueryResult.to_dict`。（无外部依赖，可立即执行）
2. **Phase 2 — 多数据库支持**：配置层扩展 → server 多池创建 → Orchestrator 路由。
3. **Phase 3 — Per-Database 安全控制**：`DatabaseSecurityConfig` → per-database validator → EXPLAIN 可配置化。
4. **Phase 4 — 弹性接入**：rate limiter 接入 → retry 退避 → rate limiter 配置化。
5. **Phase 5 — 可观测性接入**：metrics 接入 → tracing 接入。
6. **Phase 6 — 测试补全**：安全测试 → 多数据库测试 → 弹性测试 → metrics 测试。

---

## 7. 验收标准

- [ ] 配置多个数据库后，`query(database="db2")` 能正确路由到 db2 的连接池和 executor。
- [ ] 为 db1 配置 `blocked_tables=["secrets"]` 后，查询 db1 的 secrets 表被拦截，查询 db2 的 secrets 表不受影响。
- [ ] `allow_explain` 设为 `True` 的数据库可执行 EXPLAIN，设为 `False` 的被拦截。
- [ ] 并发请求超过 `max_concurrent_queries` 时，超出部分被 rate limiter 排队或拒绝。
- [ ] LLM 连续失败达到阈值后，circuit breaker 熔断，后续请求立即返回错误。
- [ ] 每次查询完成后，`pg_mcp_query_requests_total` counter 递增。
- [ ] `QueryResponse.to_dict()` 仅存在一个定义，`tokens_used` 始终包含在返回中。
- [ ] 安全测试覆盖率 ≥ 95%，总体测试覆盖率 ≥ 80%。
